import os
import pkg_resources

class IS:
    """Base module to generate instance segmentation model
    
    Class :class:`IS <justdeepit.models.IS>` generates instance segmentation models
    by internally calling the MMDetection or Detectron2 library.
    This class generates a model from the configuration file
    (``model_config``) considering the backend.

    If ``backend`` is specified to ``detectron2``,
    then calls Detectron2 package to generate a model,
    otherwise if ``mmdetection`` is specified then calls MMDetection to generate a model. 


    Args:
        class_label (str): A path to a file which contains class labels.
                       The file should be multiple rows with one column,
                       and string in each row represents a class label.
        model_arch (str): A string to specify model architecture.
                       If ``model_config`` is given, this option will be ignored.
        model_config (str): A path to configure file for building models.
                        If the configure file is not given or does not exist at the specified
                        path, then load the default configure file according ``model_arch``.
        model_weight (str): A path to a model weights. If ``None``, then use the initial
                        value that randomly generated by the packages.
        workspace (str): A path to workspace directory. Log information and checkpoints of model
                     training will be stored in this directory.
                     If ``None``, then create temporary directory in the current directory.
        backend (str): Specify the backend to build instance segmentation mode.
                   ``detectron2`` or ``mmdetection`` can be speficied.
    
    Examples:
        >>> from justdeepit.models import IS
        >>> 
        >>> # initialize Mask RCNN with random weights using MMDetection backend
        >>> model = IS('./class_label.txt', model_arch='maskrcnn', backend='mmdetection')
        >>> 
        >>> # initialize Mask RCNN with randomm weights using Detectron2 backend
        >>> model = IS('./class_label.txt', model_arch='maskrcnn', backend='detectron2')
        >>> 
        >>> # initialize Mask RCNN with trained weights using MMDetection backend
        >>> model = IS('./class_label.txt', model_arch='maskrcnn', mdoel_weight='trained_weight.pth',
        >>>            backend='mmdetection')
        >>> 
        >>> # initialize Mask RCNN with trained weights using Detectron2 backend
        >>> model = IS('./class_label.txt', model_arch='maskrcnn', model_weight='trained_weight.pth',
        >>>            backend='detectron2')
        >>> 
    """  
    
    
    def __init__(self, class_label=None, model_arch=None, model_config=None, model_weight=None, workspace=None, backend='mmdetection'):
        
        self.module = None
        self.__architectures = self.__available_architectures()
        self.__supported_formats = ('COCO',) #, 'RGB mask')
        
        self.backend = backend
        self.model_arch = model_arch
        if workspace is None:
            workspace = os.path.abspath(os.getcwd())
        self.workspace = workspace
        self.module = self.__init_module(class_label, model_arch, model_config, model_weight, workspace, backend)
    
    
    def __available_architectures(self):
        return {
            'mmdetection': [
                ['Mask R-CNN', 'mask_rcnn_x101_64x4d_fpn_mstrain-poly_3x_coco'],
                ['Cascade Mask R-CNN', 'cascade_mask_rcnn_x101_64x4d_fpn_mstrain_3x_coco.py'],
                ['custome',    None]
            ],
            'detectron2': [
                ['Mask R-CNN', 'COCO-InstanceSegmentation/mask_rcnn_R_101_FPN_3x.yaml'],
                ['custome',    None]
            ]
        }

    
    
    def __init_module(self, class_label, model_arch, model_config, model_weight, workspace, backend):
        if model_arch is None:
            return None
        
        backend_ = self.__norm_backend(backend)
        
        if model_config is None:
            # check model arch
            model_arch_ = self.__norm_arch(model_arch)
            if model_arch_ not in [self.__norm_arch(_[0]) for _ in self.__architectures[backend_]]:
                NotImplementedError('JustDeepIt does not support {} archtecture when {} is specified as a backend.'.format(model_arch, backend))

            # set model_config according to model_arch
            for available_arch, available_config in self.__architectures[backend_]:
                if model_arch_ == self.__norm_arch(available_arch):
                    if model_arch_ == 'custome':
                        if model_config is None or  model_config == '':
                            ValueError('The argument `model_config` cannot be none or empty when the user customized architecture is set.')
                    else:
                        model_config = available_config
                    break

        # init module
        module = None
        if backend_ == 'mmdetection':
            from justdeepit.models.utils.mmdetbase import MMDetBase
            module = MMDetBase(class_label, model_arch, model_config, model_weight, workspace)
        elif backend_ == 'detectron2':
            from justdeepit.models.utils.detectron2base import DetectronBase
            module = DetectronBase(class_label, model_arch, model_config, model_weight, workspace)

        return module



    def __norm_arch(self, arch):
        return arch.replace('-', '').replace(' ', '').lower()


    def __norm_backend(self, backend):
        backend_ = backend.lower()
        if backend in ['mm', 'mmdet', 'mmdetection']:
            backend_ = 'mmdetection'
        elif backend_ in ['d2', 'detectron', 'detectron2']:
            backend_ = 'detectron2'
        else:
            NotImplementedError('JustDeepIt does not support `{}` as a backend.'.format(backend))
        return backend_



    def available_architectures(self, backend):
        """Show the available architectures

        Show the available architectures for instance segmentation.

        Args:
            backend (str): Specify the backend.
                           ``detectron2`` or ``mmdetection`` can be speficied.

        Returns:
            A tuple of the supported architecture.

        Examples:
            >>> from justdeepit.models import IS
            >>>
            >>> model = IS()
            >>> model.available_architectures('mmdetection')

        """
        return tuple([_[0] for _ in self.__architectures[self.__norm_backend(backend)]])


    

    def supported_formats(self):
        """Show the supported annotation formats

        Show the supported annotation formats for instance segmentation.

        Returns:
            A tuple of the supported annotation formats.

        Examples:
            >>> from justdeepit.models import IS
            >>>
            >>> model = IS()
            >>> model.supported_formats()

        """
        return self.__supported_formats



    def __norm_format(self, x):
        x = x.replace(' ', '').replace('-', '').lower()
        if ('pascal' in x) or ('xml' in x):
            x = 'voc'
        if ('rgb' in x) and ('mask' in x):
            x = 'rgbmask'
        return x
    

    
    def train(self, image_dpath, annotation, annotation_format='COCO',
              batchsize=32, epoch=1000, lr=0.0001, score_cutoff=0.7, cpu=8, gpu=1):
        """Train model
        
        Method :func:`train <justdeepit.models.IS.train>` is used for
        training models based on MMDetection or Detectron2.
        This method requires a COCO format annotation file and
        a path to the directory containing the training images.
        
        Args:
            image_dpath (str): A path to directory which contains all training images.
            annotation (str): A file path to COCO format annotation file.
            annotation_format (str): Annotation format. Only COCO is supported in the current version.
            batch_size (int): Batch size for each GPU.
            epoch (int): Epoch.
            lr (float): Learning rate.
            score_cutoff (float): Cutoff of score for instance segmentation.
            gpu (int): Number of GPUs for model training.
            cpu (int): Number of workers for pre-prociessing images for each GPU.
        
        Examples:
            >>> from justdeepit.models import IS 
            >>> 
            >>> model = IS('./class_label.txt', model_arch='maskrcnn')
            >>> model.train('./train_images', './annotations.coco.json')
        """
        annotation_format = self.__norm_format(annotation_format)
        if annotation_format != 'coco':
            raise NotImplementedError('JustDeepIt does not support {} format for training instance segmentation model.'.format(annotation_format))
        
        self.module.train(image_dpath, annotation,
                          batchsize=batchsize, epoch=epoch, lr=lr, score_cutoff=score_cutoff,
                          cpu=cpu, gpu=gpu)
    
    
    
    def save(self, weight_fpath, config_fpath=None):
        '''Save the trained model
        
        Method :func:`save <justdeepit.models.IS.save>`
        stores the trained model weights and model configuration.
        
        Args:
            weight_fpath (str): A path to save the weights.
            config_fpath (str): A path to save the model configure. If ``None``,
                                then save the configure to file with same name
                                of ``weight_fpath`` but different extension.
        
        Examples:
            >>> from justdeepit.models import IS
            >>> 
            >>> model = IS('./class_label.txt', model_arch='maskrcnn')
            >>> model.train('./train_images', './annotations.coco.json')
            >>> odnet.save('./trained_weight.pth')
        ''' 
        self.module.save(weight_fpath, config_fpath)
    
    
    
    def inference(self, images, score_cutoff=0.7, batchsize=32, cpu=8, gpu=1):
        '''Detect objects from images
        
        Method :func:`inference <justdeepit.models.IS.inference>` is used to
        detect objects from an image or images with a given model (weights).
        
        Args:
            images (str): A path to a image file or a path to a directory which contains
                          multiple images.
            score_cutoff (float): Cutoff for instance segmentation.
            batchsize (int): Number of batches.
            gpu (int): Number of GPUs.
            cpu (int): Number of CPUs.
        
        Returns:
            :class:`ImageAnnotation <justdeepit.utils.ImageAnnotation>` class object
            or a list of :class:`ImageAnnotation <justdeepit.utils.ImageAnnotation>` class object.
        
        Examples:
            >>> import os
            >>> from justdeepit.models import IS 
            >>> 
            >>> model = IS('./class_label.txt', model_arch='maskrcnn', model_weight='./trained_weight.pth')
            >>> 
            >>> # inference single image
            >>> output = model.inference('sample.jpg')
            >>> output.draw('contour', 'output/sample.png')
            >>> 
            >>> # inference multiple images
            >>> test_images = ['sample1.jpg', 'sample2.jpg', 'sample3.jpg']
            >>> outputs = model.inference(sample_images)
            >>> for test_image, output in zip(test_images, outputs):
            >>>     bbox_img_fpath = os.path.splitext(test_image)[0] + '.bbox.png'
            >>>     output.draw('bbox+contour', bbox_img_fpath)
            >>> 
        '''
        
        return self.module.inference(images, score_cutoff=score_cutoff, batchsize=batchsize, cpu=cpu, gpu=gpu)
    
    





