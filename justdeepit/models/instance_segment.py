import os
import pkg_resources

class IS:
    """A class to generate model for instance segmentation

    The :class:`IS <justdeepit.models.IS>` class is used for generating
    deep neural network (DNN) architectures (i.e., models) for instance segmentation
    by internally calling the MMDetection or Detectron2 library.

    User can specify DNN architectures using the ``model_arch`` or ``model_config``
    argument. If the ``model_arch`` is specified and ``model_config`` is ``None``,
    the :class:`IS <justdeepit.models.IS>` class generates a DNN architecture
    according the ``model_arch`` using the pre-defined configuration.
    The pre-defined DNN architectures for instance segmentation can be checked with the
    :func:`available_architectures <justdeepit.models.IS.available_architectures>` method.
    Alternatively, if the ``model_config`` argument is specified,
    the :class:`IS <justdeepit.models.IS>` class generates a DNN architecture
    following the configuration specified with the ``model_config``,
    regardless of whether the ``model_arch`` is specified.

    The backend for generating DNN architectures can be specified to the MMDetection
    or Detectron2. Currently, the MMDetection supports more architectures than Detectron2
    and model training under GPU environments. Detectron2 can train architectures
    fast and supports CPU and GPU environments.

    Args:
        class_label (str): A path to a file which contains class labels.
                       The file should be multiple rows with one column,
                       and string in each row represents a class label.
        model_arch (str): A string to specify model architecture.
                       If ``model_config`` is given, this option will be ignored.
        model_config (str): A path to configure file for building models.
                        If the configure file is not given or does not exist at the specified
                        path, then load the default configure file according ``model_arch``.
        model_weight (str): A path to a model weights. If ``None``, then use the initial
                        value that randomly generated by the packages.
        workspace (str): A path to workspace directory. Log information and checkpoints of model
                     training will be stored in this directory.
                     If ``None``, then create temporary directory in the current directory.
        backend (str): Specify the backend to build instance segmentation mode.
                   ``detectron2`` or ``mmdetection`` can be speficied.
    
    Examples:
        >>> from justdeepit.models import IS
        >>> 
        >>> # initialize Mask RCNN with random weights using MMDetection backend
        >>> model = IS('./class_label.txt', model_arch='maskrcnn', backend='mmdetection')
        >>> 
        >>> # initialize Mask RCNN with randomm weights using Detectron2 backend
        >>> model = IS('./class_label.txt', model_arch='maskrcnn', backend='detectron2')
        >>> 
        >>> # initialize Mask RCNN with trained weights using MMDetection backend
        >>> model = IS('./class_label.txt', model_arch='maskrcnn', mdoel_weight='trained_weight.pth',
        >>>            backend='mmdetection')
        >>> 
        >>> # initialize Mask RCNN with trained weights using Detectron2 backend
        >>> model = IS('./class_label.txt', model_arch='maskrcnn', model_weight='trained_weight.pth',
        >>>            backend='detectron2')
        >>> 
    """  
    
    
    def __init__(self, class_label=None, model_arch=None, model_config=None, model_weight=None, workspace=None, backend='mmdetection'):
        
        self.module = None
        self.__architectures = self.__available_architectures()
        self.__supported_formats = ('COCO',) #, 'RGB mask')
        
        self.backend = backend
        self.model_arch = model_arch
        if workspace is None:
            workspace = os.path.abspath(os.getcwd())
        self.workspace = workspace
        self.module = self.__init_module(class_label, model_arch, model_config, model_weight, workspace, backend)
    
    
    def __available_architectures(self):
        return {
            'mmdetection': [
                ['Mask R-CNN', 'mask_rcnn_x101_64x4d_fpn_mstrain-poly_3x_coco'],
                ['Cascade Mask R-CNN', 'cascade_mask_rcnn_x101_64x4d_fpn_mstrain_3x_coco.py'],
                ['custom',    None]
            ],
            'detectron2': [
                ['Mask R-CNN', 'COCO-InstanceSegmentation/mask_rcnn_R_101_FPN_3x.yaml'],
                ['custom',    None]
            ]
        }

    
    
    def __init_module(self, class_label, model_arch, model_config, model_weight, workspace, backend):
        if model_arch is None:
            return None
        
        backend_ = self.__norm_backend(backend)
        
        if model_config is None:
            # check model arch
            model_arch_ = self.__norm_arch(model_arch)
            if model_arch_ not in [self.__norm_arch(_[0]) for _ in self.__architectures[backend_]]:
                NotImplementedError('JustDeepIt does not support {} archtecture when {} is specified as a backend.'.format(model_arch, backend))

            # set model_config according to model_arch
            for available_arch, available_config in self.__architectures[backend_]:
                if model_arch_ == self.__norm_arch(available_arch):
                    if model_arch_ == 'custom':
                        if model_config is None or  model_config == '':
                            ValueError('The argument `model_config` cannot be none or empty when the user customized architecture is set.')
                    else:
                        model_config = available_config
                    break

        # init module
        module = None
        if backend_ == 'mmdetection':
            from justdeepit.models.utils.mmdetbase import MMDetBase
            module = MMDetBase(class_label, model_arch, model_config, model_weight, workspace)
        elif backend_ == 'detectron2':
            from justdeepit.models.utils.detectron2base import DetectronBase
            module = DetectronBase(class_label, model_arch, model_config, model_weight, workspace)

        return module



    def __norm_arch(self, arch):
        return arch.replace('-', '').replace(' ', '').lower()


    def __norm_backend(self, backend):
        backend_ = backend.lower()
        if backend in ['mm', 'mmdet', 'mmdetection']:
            backend_ = 'mmdetection'
        elif backend_ in ['d2', 'detectron', 'detectron2']:
            backend_ = 'detectron2'
        else:
            NotImplementedError('JustDeepIt does not support `{}` as a backend.'.format(backend))
        return backend_



    def available_architectures(self, backend):
        """Display the pre-trained architectures for instance segmentation

        This method is used to display the DNN architectures pre-trained
        in JustDeepIt for instance segmentation.
        As the different backend supports the
        different architectures, this method requires user to specify
        the backend.

        Args:
            backend (str): Specify the backend.
                           ``detectron2`` or ``mmdetection`` can be speficied.

        Returns:
            A tuple of the supported architecture.

        Examples:
            >>> from justdeepit.models import IS
            >>>
            >>> model = IS()
            >>> model.available_architectures('mmdetection')

        """
        return tuple([_[0] for _ in self.__architectures[self.__norm_backend(backend)]])


    

    def supported_formats(self):
        """Display the supported annotation formats for training
        
        Display the supported annotation formats for traning instance segmentation architecture.

        Returns:
            A tuple of the supported annotation formats.

        Examples:
            >>> from justdeepit.models import IS
            >>>
            >>> model = IS()
            >>> model.supported_formats()

        """
        return self.__supported_formats



    def __norm_format(self, x):
        x = x.replace(' ', '').replace('-', '').lower()
        if ('pascal' in x) or ('xml' in x):
            x = 'voc'
        if ('rgb' in x) and ('mask' in x):
            x = 'rgbmask'
        return x
    

    
    def train(self, image_dpath, annotation, annotation_format='COCO',
              optimizer=None, scheduler=None,
              batchsize=8, epoch=100, score_cutoff=0.5, cpu=4, gpu=1):
        """Train model
 
        The :func:`train <justdeepit.models.IS.train>` is used for training a model.
        The training images (``image_dpath``), annotation files (``annotation``),
        and annotation format (``annotation_format``) must be specified.
        Note that, the current version of JustDeepIt only supports COCO format.
        
        Args:
            image_dpath (str): A path to directory which contains all training images.
            annotation (str): A file path to COCO format annotation file.
            annotation_format (str): Annotation format. Only COCO is supported in the current version.
            optimizer (str): String to specify optimizer/solver supported by MMDetection or Detectron2.
            scheduler (str): String to specify optimization scheduler.
            batchsize (int): Batch size for each GPU.
            epoch (int): Epoch.
            score_cutoff (float): Cutoff of score for instance segmentation.
            cpu (int): Number of workers for pre-prociessing images for each GPU.
            gpu (int): Number of GPUs for model training.
        
        Examples:
            >>> from justdeepit.models import IS 
            >>> 
            >>> model = IS('./class_label.txt', model_arch='maskrcnn')
            >>> model.train('./train_images', './annotations.coco.json', 'COCO')
        """
        annotation_format = self.__norm_format(annotation_format)
        if annotation_format != 'coco':
            raise NotImplementedError('JustDeepIt does not support {} format for training instance segmentation model.'.format(annotation_format))
        
        self.module.train(image_dpath, annotation,
                          optimizer, scheduler,
                          batchsize=batchsize, epoch=epoch, score_cutoff=score_cutoff,
                          cpu=cpu, gpu=gpu)
    
    
    
    def save(self, weight_fpath, config_fpath=None):
        '''Save the trained model
        
        Method :func:`save <justdeepit.models.IS.save>`
        stores the trained model weights and model configuration.
        
        Args:
            weight_fpath (str): A path to save the weights.
            config_fpath (str): A path to save the model configure. If ``None``,
                                then save the configure to file with same name
                                of ``weight_fpath`` but different extension.
        
        Examples:
            >>> from justdeepit.models import IS
            >>> 
            >>> model = IS('./class_label.txt', model_arch='maskrcnn')
            >>> model.train('./train_images', './annotations.coco.json')
            >>> odnet.save('./trained_weight.pth')
        ''' 
        self.module.save(weight_fpath, config_fpath)
    
    
    
    def inference(self, images, score_cutoff=0.5, batchsize=8, cpu=4, gpu=1):
        '''Detect objects from images
        
        Method :func:`inference <justdeepit.models.IS.inference>` is used to
        detect objects from an image or images with a given model (weights).
        
        Args:
            images (str): A path to a image file or a path to a directory which contains
                          multiple images.
            score_cutoff (float): Cutoff for instance segmentation.
            batchsize (int): Number of batches.
            cpu (int): Number of CPUs.
            gpu (int): Number of GPUs.
        
        Returns:
            :class:`ImageAnnotation <justdeepit.utils.ImageAnnotation>` class object
            or a list of :class:`ImageAnnotation <justdeepit.utils.ImageAnnotation>` class object.
        
        Examples:
            >>> import os
            >>> from justdeepit.models import IS 
            >>> 
            >>> model = IS('./class_label.txt', model_arch='maskrcnn', model_weight='./trained_weight.pth')
            >>> 
            >>> # inference single image
            >>> output = model.inference('sample.jpg')
            >>> output.draw('contour', 'output/sample.png')
            >>> 
            >>> # inference multiple images
            >>> test_images = ['sample1.jpg', 'sample2.jpg', 'sample3.jpg']
            >>> outputs = model.inference(sample_images)
            >>> for test_image, output in zip(test_images, outputs):
            >>>     bbox_img_fpath = os.path.splitext(test_image)[0] + '.bbox.png'
            >>>     output.draw('bbox+contour', bbox_img_fpath)
            >>> 
        '''
        
        return self.module.inference(images, score_cutoff=score_cutoff, batchsize=batchsize, cpu=cpu, gpu=gpu)
    
    





